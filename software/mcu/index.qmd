---
title: MCU Design
---
The project employs the STM32 Nucleo-32 board with an STM32L432KC MCU, facilitating direct I2C communication with three LSM6DSO32 IMUs from AdaFruit. The received data is converted into helpful information for the FPGA, and the generated data is sent to the FPGA via SPI. On this page, I am focusing on the software side of this system. However, the schematic below will give insight into the hardware implementation of this software's overall embedded system.

# LSM6DSO32 IMUs
We chose theme IMUs for their highly customizable accelerometer peripherals, I2C capabilities, and price. In this project, we take these IMUs, mount them to the shin, femur, and torso of the user, then decode the angles, and from that, we place the (X, Y) positions of the toe, heel, knee, hip, and head on a 2D plane, which is then sent to the FPGA to perform its duties.

![LSM6DS032 IMU [source link](https://learn.adafruit.com/assets/85936)](images/imu_front.jpeg)

## Addressing (I2C)
To fully take advantage of I2C and chain together multiple IMUs on one I2C communication bus, the chip address must be changed on one of the chips to alter the LSB of the address value. The figure below highlights what needed to be bridged.

![IMU Backside [source link](https://learn.adafruit.com/lsm6dsox-and-ism330dhc-6-dof-imu)](images/imu_back.jpeg)

## Configuring IMU Accelerometer
Configuration of the IMU accelerometer peripheral allows us to configure the communication speed, resolution, range, and other data parameters we receive. For our use, the CTRL1_XL register was configured with an ODR at 104Hz (normal mode), +/- 8g range, and enable LPF2 data filtering.

![LSM6DS032 Accelerometer Control Register [datasheet](https://www.st.com/resource/en/datasheet/lsm6dso32.pdf)](images/ctrl1_xl.jpeg)

----------------------------------------------------------

# STM34L432KC MCU Peripherals & Programming Structure
- intro to what I will be talking about (talk about why using that funciton, and how it looks in code)
- also talk about the main coding structure diagram, with GAME LOGIC as a black box
- Talk about what peripherals I am going to talk about

## GPIO
initializing GPIO pins, and what pins can I use with I2C

## I2C1 & I2C3
how I am going to use I2C

### Initialization
what is needed to initialize and why

### Writing With I2C
how to write

### Reading With I2C
how to read

### Simulation
Simulation of the I2C protocol and all of the specific data transfers

## SPI
why am I using

### Configuration


### Read/Write With SPI
By nature with SPI, whenever you send data you receive some too

### Simulation


----------------------------------------------------------

# Game Logic
Talk about the GAME LOGIC block by itself and how that works
- Put the picture that I drew up

## Reading Accel Data
Not how reading with I2C works, but what am I reading (reference the read function that I wrote above)

## Angle Decode
- How do I decode the angles
- Talk about taking care of wierd data

## Decode The Positions
How do I do this
- talk about the wierdness with the origin being in the top left and not bottom left
